
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Programming // Neon Nexus</title>
  <link rel="stylesheet" href="../styles/main.css">
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
  <style>:root { --neon-lime: #00ff00; }</style>
</head>
<body class="l-layout u-bg-gradient">

  <header class="header">
    <div class="l-container header__nav">
      <a href="../index.html" class="header__logo u-text-glow">Neon Nexus // ALGO</a>
      <nav>
        <a href="../index.html" class="c-card__title" style="text-decoration: none; font-size: 0.9rem;">BACK âžœ</a>
      </nav>
    </div>
  </header>

  <main class="l-container">
    <section class="hero">
      <h1 class="hero__title u-text-glow">Dynamic Programming</h1>
      <p class="u-text-muted">Breaking complex problems into overlapping subproblems for optimal efficiency.</p>
    </section>

    <div id="algo-container">
      <!-- Algorithms Injected via DOM API -->
    </div>
  </main>

  <footer class="footer">
    <div class="l-container">
      <p>&copy; 2026 NEON-NOIR ARCHITECT MANIFESTO</p>
    </div>
  </footer>

  <script src="../scripts/dom-engine.js"></script>
  <script>
    window.ALGO_DATA = [
      {
        title: "Fibonacci (Memoization)",
        code: `function fib(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 2) return 1;
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
}`,
        explanation: [
          "Check if the result for the current 'n' is already in the memo.",
          "Base cases: Fibonacci(1) and Fibonacci(2) are both 1.",
          "Recursively calculate the sum of the previous two numbers.",
          "Store the result in the memo before returning it to the caller.",
          "Return the final memoized value."
        ]
      },
      {
        title: "Knapsack Problem",
        code: `function knapsack(val, wt, W) {
  const n = val.length;
  const dp = Array(n + 1).fill().map(() => Array(W + 1).fill(0));
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= W; j++) {
      if (wt[i-1] <= j) {
        dp[i][j] = Math.max(val[i-1] + dp[i-1][j-wt[i-1]], dp[i-1][j]);
      } else dp[i][j] = dp[i-1][j];
    }
  }
  return dp[n][W];
}`,
        explanation: [
          "Get the number of items available for the knapsack.",
          "Create a 2D array for dynamic programming state storage.",
          "Outer loop iterates through available items one by one.",
          "Inner loop iterates through every capacity from 1 up to W.",
          "Check if the current item's weight is less than or equal to current capacity.",
          "Update the maximum value by comparing including vs. excluding the item.",
          "If the item is too heavy, simply take the previous best for that capacity.",
          "Return the maximum value possible for the total capacity W."
        ]
      },
      {
        title: "Longest Common Subsequence",
        code: `function lcs(text1, text2) {
  const m = text1.length, n = text2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i-1] === text2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
      else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
    }
  }
  return dp[m][n];
}`,
        explanation: [
          "Initialize dimensions based on the lengths of both strings.",
          "Set up the 2D DP matrix to store subsequence lengths.",
          "Iterate through both strings using nested loops.",
          "Check if characters at current positions are matching.",
          "If characters match, increment the length of the previous LCS.",
          "If they don't match, take the maximum from excluding either character.",
          "Return the total length of the longest common subsequence."
        ]
      },
      {
        title: "Coin Change Problem",
        code: `function coinChange(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  for (const coin of coins) {
    for (let i = coin; i <= amount; i++) {
      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
}`,
        explanation: [
          "Initialize an array of 'amount + 1' with infinity.",
          "Set the base case: 0 coins are needed for an amount of 0.",
          "Loop through each available coin denomination.",
          "Iterate from current coin value up to the target amount.",
          "Update the minimum coins needed using the current denomination.",
          "Check if the final amount is reachable or remains infinity.",
          "Return the minimum number of coins or -1 if impossible."
        ]
      },
      {
        title: "Matrix Chain Multiplication",
        code: `function matrixChain(p) {
  const n = p.length - 1;
  const m = Array(n + 1).fill().map(() => Array(n + 1).fill(0));
  for (let L = 2; L <= n; L++) {
    for (let i = 1; i <= n - L + 1; i++) {
      const j = i + L - 1;
      m[i][j] = Infinity;
      for (let k = i; k < j; k++) {
        const q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
        if (q < m[i][j]) m[i][j] = q;
      }
    }
  }
  return m[1][n];
}`,
        explanation: [
          "Determine the number of matrices to multiply.",
          "Create a DP table 'm' to store costs of multiplications.",
          "L is the chain length, starting from 2 up to the total number.",
          "Outer loop for the starting index 'i' of the chain.",
          "Calculate the ending index 'j' of the current chain.",
          "Find the split point 'k' that minimizes the multiplication cost.",
          "Update the DP table with the optimal split cost.",
          "Return the minimum multiplication operations needed for the entire chain."
        ]
      }
    ];
    new AlgoEngine("Dynamic Programming", "#00ff00");
  </script>
</body>
</html>
