
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Number Theory // Neon Nexus</title>
  <link rel="stylesheet" href="../styles/main.css">
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
  <style>:root { --neon-lime: #ccff00; }</style>
</head>
<body class="l-layout u-bg-gradient">

  <header class="header">
    <div class="l-container header__nav">
      <a href="../index.html" class="header__logo u-text-glow">Neon Nexus // ALGO</a>
      <nav>
        <a href="../index.html" class="c-card__title" style="text-decoration: none; font-size: 0.9rem;">BACK âžœ</a>
      </nav>
    </div>
  </header>

  <main class="l-container">
    <section class="hero">
      <h1 class="hero__title u-text-glow">Number Theory</h1>
      <p class="u-text-muted">The mathematical heart of modern computation and cryptography.</p>
    </section>

    <div id="algo-container">
      <!-- Algorithms Injected via DOM API -->
    </div>
  </main>

  <footer class="footer">
    <div class="l-container">
      <p>&copy; 2026 NEON-NOIR ARCHITECT MANIFESTO</p>
    </div>
  </footer>

  <script src="../scripts/dom-engine.js"></script>
  <script>
    window.ALGO_DATA = [
      {
        title: "Euclidean Algorithm (GCD)",
        code: `function gcd(a, b) {
  while (b) {
    a %= b;
    [a, b] = [b, a];
  }
  return a;
}`,
        explanation: [
          "Continue the loop while the second number is non-zero.",
          "Calculate the remainder of the first divided by the second.",
          "Update the numbers by swapping the remainder into the second position.",
          "The loop terminates when 'b' is zero, leaving 'a' as the GCD.",
          "Return the result (Greatest Common Divisor)."
        ]
      },
      {
        title: "Sieve of Eratosthenes",
        code: `function sieve(n) {
  const primes = new Array(n + 1).fill(true);
  primes[0] = primes[1] = false;
  for (let p = 2; p * p <= n; p++) {
    if (primes[p]) {
      for (let i = p * p; i <= n; i += p) primes[i] = false;
    }
  }
  return primes.map((p, i) => p ? i : null).filter(p => p);
}`,
        explanation: [
          "Create a boolean array initialized to true for all potential primes.",
          "Set 0 and 1 as false since they are not prime.",
          "Loop starting from 2 up to the square root of n.",
          "If the current number is marked as prime, it's a true prime.",
          "Inner loop: mark all multiples of the current prime as composite.",
          "Map the boolean array back to the prime numbers themselves.",
          "Filter out nulls and return the list of prime numbers."
        ]
      },
      {
        title: "Modular Exponentiation",
        code: `function modExp(base, exp, mod) {
  let res = 1n;
  base %= mod;
  while (exp > 0n) {
    if (exp % 2n === 1n) res = (res * base) % mod;
    base = (base * base) % mod;
    exp /= 2n;
  }
  return res;
}`,
        explanation: [
          "Initialize the result to 1 using BigInt notation.",
          "Reduce the base modulo the given mod value.",
          "Continue while the exponent is positive.",
          "If the exponent is odd, multiply the current base into the result.",
          "Square the base modulo the modulus (Exponentiation by Squaring).",
          "Divide the exponent by 2 (right shift).",
          "Return the final modular result."
        ]
      },
      {
        title: "Extended Euclidean Algorithm",
        code: `function extendedGCD(a, b) {
  if (b === 0) return [a, 1, 0];
  const [g, x1, y1] = extendedGCD(b, a % b);
  return [g, y1, x1 - Math.floor(a / b) * y1];
}`,
        explanation: [
          "Recursive base case: if b is 0, the GCD is 'a', with x=1 and y=0.",
          "Recursively calculate the GCD and coefficients for (b, a % b).",
          "Update the coefficients using the recursive results.",
          "Return an array containing [GCD, coefficient x, coefficient y]."
        ]
      },
      {
        title: "Miller-Rabin Primality Test",
        code: `function millerRabin(n, k = 5) {
  if (n < 4) return n === 2 || n === 3;
  let d = BigInt(n - 1), s = 0;
  while (d % 2n === 0n) { d /= 2n; s++; }
  // Test K times with random bases
  // ... simplification for display
}`,
        explanation: [
          "Handle base cases for small numbers (2 and 3 are prime).",
          "Factor out powers of 2 from n-1, finding 'd' and 's'.",
          "Continue reducing n-1 while it's even.",
          "This sets up the decomposition (n-1) = 2^s * d.",
          "The test then picks random bases to perform modular exponentiation.",
          "The accuracy improves exponentially with the number of rounds (k)."
        ]
      }
    ];
    new AlgoEngine("Number Theory", "#ccff00");
  </script>
</body>
</html>
